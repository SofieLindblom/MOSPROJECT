<html>
	<head>
		<title>AMAZEBALLS</title>
		<style>canvas { width: 100%; height: 100% }</style>
	</head>
	<body>
		<script src="https://rawgithub.com/mrdoob/three.js/master/build/three.js"></script>
		<script src="Lib/three.min.js"></script>
		<script src="Lib/TrackballControls.js"></script>
		<script src="Lib/stats.min.js"></script>
		<script src="Lib/Detector.js"></script>
		
		<script>
			
			//Global variables
			var balls = []; 
			var Nr_of_balls = 50;
	      	var primary_energy_loss = 0.9;
	      	var secondary_energy_loss = 0.95;
	      	var max_nr_of_bounces = 50;
	      	var time = 0;
	      	var dt = 0;
	      	var change;

			//Set up Scene
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

			camera.position.x = 100;
       		camera.position.y = 50;
       		camera.position.z = 50;

			var renderer = new THREE.WebGLRenderer({ antialias: false });
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );
			renderer.shadowMapEnabled = true;

			//Mouse navigation
			var controls = new THREE.TrackballControls( camera );

			controls.rotateSpeed = 1.0;
			controls.zoomSpeed = 1.2;
			controls.panSpeed = 0.8;
			controls.noZoom = false;
			controls.noPan = false;
			controls.staticMoving = true;
			controls.dynamicDampingFactor = 0.3;
			controls.keys = [ 65, 83, 68 ];
			controls.addEventListener( 'change', render );
			window.addEventListener( 'resize', onWindowResize, false );

			//Axis helper
			var axisHelper = new THREE.AxisHelper( 10 );
			scene.add( axisHelper );

       		//Add lightning
			var light = new THREE.SpotLight();
	      	light.position.set( 10, 100, 50 );
	      	scene.add(light);
	      	light.castShadow = true;

			var litCube = new THREE.Mesh(
	        new THREE.CubeGeometry(2, 3, 7),
	        new THREE.MeshLambertMaterial({color: 0x00FFFF}));
	      	litCube.position.y = 1;
	      	litCube.position.x = 1;
	      	litCube.position.z = 1;
	      	litCube.castShadow = true;
	      	litCube.receiveShadow = true;
	      	scene.add(litCube);

	      	//Add ground plane
	      	var planeGeo = new THREE.PlaneGeometry(100, 100, 10, 10);
			var planeMat = new THREE.MeshLambertMaterial({color: 0xFFFFFF});
			var plane = new THREE.Mesh(planeGeo, planeMat);		
			plane.rotation.x = -Math.PI/2;
			plane.position.y = -50;
			
			//Add wireframe for box  
			var cube = new THREE.Mesh(new THREE.CubeGeometry(100, 100, 100), new THREE.MeshBasicMaterial({
        	wireframe: true,
        	color: 'blue'}));      		
      		scene.add(cube);
			plane.receiveShadow = true;
			scene.add(plane);

			//Create balls and store in array
			var geom = new THREE.SphereGeometry(1,16,16);
			    for (var i = 0; i < Nr_of_balls; i++) {
				        var ball = {};
				        ball.obj = new THREE.Mesh( 
				            geom, 
				            new THREE.MeshLambertMaterial({
				                color: Math.floor(Math.random() * 0x1000000)
			            })
			        );

					//Set initial position and velocity
			        ball.x = 18*Math.random() - 9;   
			        ball.y = 18*Math.random() - 9;
			        ball.z = 18*Math.random() - 9;
			        ball.dx = Math.random();  
			        ball.dy = Math.random();
			        ball.dz = Math.random();
			        ball.count = 0;
			        if (Math.random() < 0.5)
			            ball.dx = -ball.dx;
			        if (Math.random() < 0.5)
			            ball.dy = -ball.dy;
			        if (Math.random() < 0.5)
			            ball.dz = -ball.dz;
			        ball.obj.position.set( ball.x, ball.y, ball.z);
			        scene.add(ball.obj);
			        ball.obj.castShadow = true;
			        ball.obj.recieveShadow = true;
			        balls.push(ball);
				}//End creation of balls
				
				//Adjusted window size trigged by mouse navigation 
				function onWindowResize() {
					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();
					renderer.setSize( window.innerWidth, window.innerHeight );
					controls.handleResize();
					render();
				}	
			
			//Navigation with arrow buttons
			window.addEventListener('keydown', function (event){

			     var code = event.keyCode;
			     console.log(code);
			     if (event.charCode && code == 0)
			          	code = event.charCode;
			    
			     switch(code) {
			          case 37://, 65:
			              console.log("left");
					      camera.position.x -= 2;//((new THREE.Vector3(0, 1, 0)).normalize(), degInRad(1));		
			              break;
			          case 38://, 87:
			              //console.log("up");
			              camera.position.z -= 2;
			              //camera.rotateOnAxis((new THREE.Vector3(1, 0, 0)).normalize(), degInRad(1));
			              break;
			          case 39://, 68:
			              //console.log("right");
			              //camera.rotateOnAxis((new THREE.Vector3(0, 1, 0)).normalize(), degInRad(-1));
			              camera.position.x += 2;
			              break;
			          case 40://, 83:
			              //console.log("down");
			              //camera.rotateOnAxis((new THREE.Vector3(1, 0, 0)).normalize(), degInRad(-1));
			              camera.position.z += 2;
			              break;
			     }
			}, false); //End navigation with arrow buttons

			//Update object's positions: 60 frames/second (?)
			function animate(t) {

		        litCube.position.x = Math.sin(t/1000)*7;
		        litCube.position.y = Math.cos(t/1000)*5;
		        litCube.position.z = 15;
		        		        
		        //Clock 채r inbyggd i threejs, tror det 채r vad vi ska anv채nda, kika p책 andra balls exemplet
		        //dt = t-time;
		        //time = t;
		        //console.log(dt);
		        //var dt = clock.getDelta(); 

		        for (var i = 0; i < Nr_of_balls; i++) {
		        
		    			//If ball hits ground y-direction
					    if(balls[i].y <= -49){
					    	balls[i].dy =  -balls[i].dy*primary_energy_loss;
					    	balls[i].dx =  balls[i].dx*secondary_energy_loss;
					    	balls[i].dz =  balls[i].dz*secondary_energy_loss;
					    	//balls[i].dy =  balls[i].dy - 9.82/1000;
					    	balls[i].x = balls[i].x  + balls[i].dx;   // update position, constant velocity
							balls[i].y = balls[i].y  + balls[i].dy;
							balls[i].z = balls[i].z  + balls[i].dz;
							balls[i].count++;
							//Prevent infinite number of bounces
							if(balls[i].count>max_nr_of_bounces && balls[i].y < -48)
							{
								balls[i].dy =  0;
						    	balls[i].dx =  0;
						    	balls[i].dz =  0;
							}
						}
						else if(balls[i].x < -49 || balls[i].x > 49){
					    	balls[i].dy =  balls[i].dy*secondary_energy_loss;
					    	balls[i].dx =  -balls[i].dx*primary_energy_loss;
					    	balls[i].dz =  balls[i].dz*secondary_energy_loss;
					    	balls[i].dy =  balls[i].dy - 9.82/1000;


					    	balls[i].x = balls[i].x  + balls[i].dx;   // update position, constant velocity
							balls[i].y = balls[i].y  + balls[i].dy;
							balls[i].z = balls[i].z  + balls[i].dz;
							balls[i].count++;
						}
						else if(balls[i].z < -49 || balls[i].z > 49){
					    	balls[i].dy =  balls[i].dy*secondary_energy_loss;
					    	balls[i].dx =  balls[i].dx*secondary_energy_loss;
					    	balls[i].dz =  -balls[i].dz*primary_energy_loss;
					    	balls[i].dy =  balls[i].dy - 9.82/1000;

					    	balls[i].x = balls[i].x  + balls[i].dx;   // update position, constant velocity
							balls[i].y = balls[i].y  + balls[i].dy;
							balls[i].z = balls[i].z  + balls[i].dz;
							balls[i].count++;
						}
						else{
							if(balls[i].y > -49){
							balls[i].dy =  balls[i].dy - 9.82/1000;
							}
							balls[i].x = balls[i].x  + balls[i].dx;   // update position, constant velocity
							balls[i].y = balls[i].y  + balls[i].dy;
							balls[i].z = balls[i].z  + balls[i].dz;
						}

				     balls[i].obj.position.set( balls[i].x , balls[i].y , balls[i].z );
				     controls.update();

		        } //End for Loop

		        camera.lookAt(scene.position);
		        // renderer automatically clears unless autoClear = false
		        renderer.render(scene, camera);
		        window.requestAnimationFrame(animate, renderer.domElement);

		    }; //End animate functon

		    
		    animate(new Date().getTime()) ;

		    function degInRad(deg) {
			    return deg * Math.PI / 180;
			}  

			function render() {
				renderer.render( scene, camera );
			}
		</script>
	</body>
</html>