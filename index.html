<html>
	<head>
		<title>AMAZEBALLS</title>
		<style>canvas { width: 100%; height: 100% }</style>
	</head>
	<body>
		<script src="https://rawgithub.com/mrdoob/three.js/master/build/three.js"></script>
		<script src="Lib/three.min.js"></script>
		<script src="Lib/TrackballControls.js"></script>
		<!--<script src="Lib/stats.min.js"></script>-->
		<script src="Lib/Detector.js"></script>
		
		<script>
			
			//Global variables
			var balls = []; 
			var Nr_of_balls = 50;
	      	var primary_energy_loss = 0.9;
	      	var secondary_energy_loss = 0.95;
	      	var max_nr_of_bounces = 20;
	      	var time = 0;
	      	var radius = 1;
	      	var dt = 0;
	      	var temp = 0.0;
	      	var change;

			//Set up Scene
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

			camera.position.x = 100;
       		camera.position.y = 50;
       		camera.position.z = 50;

			var renderer = new THREE.WebGLRenderer({ antialias: false });
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );
			renderer.shadowMapEnabled = true;

			//Mouse navigation
			var controls = new THREE.TrackballControls( camera );

			controls.rotateSpeed = 1.0;
			controls.zoomSpeed = 1.2;
			controls.panSpeed = 0.8;
			controls.noZoom = false;
			controls.noPan = false;
			controls.staticMoving = true;
			controls.dynamicDampingFactor = 0.3;
			//controls.keys = [ 65, 83, 68 ];
			controls.addEventListener( 'change', render );
			window.addEventListener( 'resize', onWindowResize, false );

			//Axis helper
			var axisHelper = new THREE.AxisHelper( 10 );
			scene.add( axisHelper );

       		//Add lightning
			var light = new THREE.SpotLight();
	      	light.position.set( 10, 100, 50 );
	      	scene.add(light);
	      	light.castShadow = true;

			var litCube = new THREE.Mesh(
	        new THREE.CubeGeometry(2, 3, 7),
	        new THREE.MeshLambertMaterial({color: 0x00FFFF}));
	      	litCube.position.y = 1;
	      	litCube.position.x = 1;
	      	litCube.position.z = 1;
	      	litCube.castShadow = true;
	      	litCube.receiveShadow = true;
	      	scene.add(litCube);

	      	//Add ground plane
	      	var planeGeo = new THREE.PlaneGeometry(100, 100, 10, 10);
			var planeMat = new THREE.MeshLambertMaterial({color: 0xFFFFFF});
			var plane = new THREE.Mesh(planeGeo, planeMat);		
			plane.rotation.x = -Math.PI/2;
			plane.position.y = -50;
			
			//Add wireframe for box  
			var cube = new THREE.Mesh(new THREE.CubeGeometry(100, 100, 100), new THREE.MeshBasicMaterial({
        	wireframe: true,
        	color: 'blue'}));      		
      		scene.add(cube);
			plane.receiveShadow = true;
			scene.add(plane);

			//Create balls and store in array
			var geom = new THREE.SphereGeometry(1,16,16);
			    for (var i = 0; i < Nr_of_balls; i++) {
				        var ball = {};
				        ball.obj = new THREE.Mesh( 
				            geom, 
				            new THREE.MeshLambertMaterial({
				                color: Math.floor(Math.random() * 0x1000000)
			            })
			        );

					//Set initial position and velocity
			        ball.x = 18*Math.random() - 9;   
			        ball.y = 18*Math.random() - 9;
			        ball.z = 18*Math.random() - 9;
			        ball.dx = Math.random();  
			        ball.dy = Math.random();
			        ball.dz = Math.random();
			        ball.count = 0;
			        if (Math.random() < 0.5)
			            ball.dx = -ball.dx;
			        if (Math.random() < 0.5)
			            ball.dy = -ball.dy;
			        if (Math.random() < 0.5)
			            ball.dz = -ball.dz;
			        ball.obj.position.set( ball.x, ball.y, ball.z);
			        scene.add(ball.obj);
			        ball.obj.castShadow = true;
			        ball.obj.recieveShadow = true;
			        balls.push(ball);
				}//End creation of balls
				
				//Adjusted window size trigged by mouse navigation 
				function onWindowResize() {
					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();
					renderer.setSize( window.innerWidth, window.innerHeight );
					controls.handleResize();
					render();
				}	
			
			//Navigation with arrow buttons
			window.addEventListener('keydown', function (event){

			     var code = event.keyCode;
			     console.log(code);
			     if (event.charCode && code == 0)
			          	code = event.charCode;
			    
			     switch(code) {
			          case 37://, 65:
			              console.log("left");
					      camera.position.x -= 2;//((new THREE.Vector3(0, 1, 0)).normalize(), degInRad(1));		
			              break;
			          case 38://, 87:
			              //console.log("up");
			              camera.position.z -= 2;
			              //camera.rotateOnAxis((new THREE.Vector3(1, 0, 0)).normalize(), degInRad(1));
			              break;
			          case 39://, 68:
			              //console.log("right");
			              //camera.rotateOnAxis((new THREE.Vector3(0, 1, 0)).normalize(), degInRad(-1));
			              camera.position.x += 2;
			              break;
			          case 40://, 83:
			              //console.log("down");
			              //camera.rotateOnAxis((new THREE.Vector3(1, 0, 0)).normalize(), degInRad(-1));
			              camera.position.z += 2;
			              break;
			     }
			}, false); //End navigation with arrow buttons

			//Update object's positions: 60 frames/second (?)
			function animate(t) {

		        litCube.position.x = Math.sin(t/1000)*7;
		        litCube.position.y = Math.cos(t/1000)*5;
		        litCube.position.z = 15;
		        		        
		        //Clock är inbyggd i threejs, tror det är vad vi ska använda, kika på andra balls exemplet
		        //dt = t-time;
		        //time = t;
		        //console.log(dt);
		        //var dt = clock.getDelta(); 
		        bounce_check();
		       

		        
			     controls.update();

		

		        camera.lookAt(scene.position);
		        // renderer automatically clears unless autoClear = false
		        renderer.render(scene, camera);
		        window.requestAnimationFrame(animate, renderer.domElement);

		    }; //End animate functon

		    
		    animate(new Date().getTime()) ;

		    function bounce_check()
		    {
		    	 for (var i = 0; i < Nr_of_balls; i++) {
		        
		    			//If ball hits ground y-direction
					    if(balls[i].y <= -49){
					    	balls[i].dy =  -balls[i].dy*primary_energy_loss;
					    	balls[i].dx =  balls[i].dx*secondary_energy_loss;
					    	balls[i].dz =  balls[i].dz*secondary_energy_loss;
					    	//balls[i].dy =  balls[i].dy - 9.82/1000;

					    	balls[i].y = -49;
					    	if(balls[i].x < -49)
					    		balls[i].x = -49;
					    	else if (balls[i].x > 49)
					    		balls[i].x = 49;
					    	if(balls[i].z < -49)
					    		balls[i].z = -49;
					    	else if (balls[i].z > 49)
					    		balls[i].z = 49;

					    	//balls[i].x = balls[i].x  + balls[i].dx;   // update position, constant velocity
							//balls[i].y = balls[i].y  + balls[i].dy;
							//balls[i].z = balls[i].z  + balls[i].dz;
							balls[i].count++;
							//Prevent infinite number of bounces
							if(balls[i].count>max_nr_of_bounces) //&& balls[i].y < -48)
							{
								balls[i].y = -49;
								balls[i].dy =  0;
						    	balls[i].dx =  0;
						    	balls[i].dz =  0;
							}
						}
						else if(balls[i].x < -49 || balls[i].x > 49){
					    	balls[i].dy =  balls[i].dy*secondary_energy_loss;
					    	balls[i].dx =  -balls[i].dx*primary_energy_loss;
					    	balls[i].dz =  balls[i].dz*secondary_energy_loss;
					    	balls[i].dy =  balls[i].dy - 9.82/1000;

					    	if(balls[i].x < -49)
					    		balls[i].x = -49;
					    	else
					    		balls[i].x = 49;
					    	if(balls[i].z < -49)
					    		balls[i].z = -49;
					    	else if(balls[i].z > 49)
					    		balls[i].z = 49;

					    	//balls[i].x = balls[i].x  + balls[i].dx;   // update position, constant velocity
							//balls[i].y = balls[i].y  + balls[i].dy;
							//balls[i].z = balls[i].z  + balls[i].dz;
							balls[i].count++;
						}
						else if(balls[i].z < -49 || balls[i].z > 49){
					    	balls[i].dy =  balls[i].dy*secondary_energy_loss;
					    	balls[i].dx =  balls[i].dx*secondary_energy_loss;
					    	balls[i].dz =  -balls[i].dz*primary_energy_loss;
					    	balls[i].dy =  balls[i].dy - 9.82/1000;


					    	if(balls[i].z < -49)
					    		balls[i].z = -49;
					    	else
					    		balls[i].z = 49;

					    	//balls[i].x = balls[i].x  + balls[i].dx;   // update position, constant velocity
							//balls[i].y = balls[i].y  + balls[i].dy;
							//balls[i].z = balls[i].z  + balls[i].dz;
							balls[i].count++;
						}


			     for (var j = 0; j < Nr_of_balls; j++) {
			     	if(i!=j && collision(balls[i], balls[j]) == true)
			     	{
			     		// Följande är ungefär så vi borde göra men funkar ej så bra


			     		//get velocities for the colliding balls
			     		var v1 = new THREE.Vector3( balls[i].dx, balls[i].dy, balls[i].dz );
			     		var v2 = new THREE.Vector3( balls[j].dx, balls[j].dy, balls[j].dz );
			     		var p1 = new THREE.Vector3( balls[i].dx, balls[i].dy, balls[i].dz );
			     		var p2 = new THREE.Vector3( balls[j].dx, balls[j].dy, balls[j].dz );
			     		//console.log(v1.length() + " vlength ");
			     		var l1 = v1.length();
			     		var l2 = v2.length();
			     		//console.log(l1 + " <- v1.length(), v2 -> " + l2);
			     		//calculate the normal and tangent vectors before the collision
			     		v1.normalize();
			     		v2.normalize();
			     		//p1.normalize();
			     		//p2.normalize();
//			     		console.log(v1.length() + " <- v1 length");
			     		var normal = new THREE.Vector3( p1.x-p2.x, p1.y-p2.y, p1.z-p2.z );
//			     		console.log(normal.length() + " <- normal length");
						var len = normal.length();
			     		//console.log(len + " <- normal length");
			     		normal.normalize();




			     		// http://stackoverflow.com/questions/11132681/what-is-a-formula-to-get-a-vector-perpendicular-to-another-vector		     		
			     		var tz = (-(normal.x*0.3) - (normal.y*0.3) ) / normal.z;
			     		var tangent = new THREE.Vector3( 0.3, 0.3, tz);
			     		
			     		tangent.normalize();
			     		//console.log(normal.x);
			     		//console.log(normal.angleTo(tangent));



			     		

			     		//get normal and tangent projections for v1 and v2
			     		var v1n = v1.projectOnVector(normal);
			     		//console.log(v1n.length() );
			     		var v1t = v1.projectOnVector(tangent);

			     		var v2n = v2.projectOnVector(normal);
			     		var v2t = v2.projectOnVector(tangent);

			     		// v1a = vel for ball 1 after collision = the normal composant of ball 2 + the tangent component for ball 1
			     		var v2an = new THREE.Vector3((secondary_energy_loss*(v1n.x - v2n.x) + v1n.x + v2n.x)/2, 
			     										(secondary_energy_loss*(v1n.y - v2n.y) + v1n.y + v2n.y)/2,
			     										(secondary_energy_loss*(v1n.z - v2n.z) + v1n.z + v2n.z)/2);

			     		var v1an = new THREE.Vector3(v1n.x+v2n.x-v2an.x, v1n.y+v2n.y-v2an.y, v1n.z+v2n.z-v2an.z);

			     		var v1a = new THREE.Vector3( v1an.x + v1t.x, v1an.y + v1t.y, v1an.z + v1t.z);
			     		var v2a = new THREE.Vector3( v2an.x + v2t.x, v2an.y + v2t.y, v2an.z + v2t.z);
			     		//var v1a = new THREE.Vector3( v2n.x + v1t.x, v2n.y + v1t.y, v2n.z + v1t.z);
			     		//var v2a = new THREE.Vector3( v1n.x + v2t.x, v1n.y + v2t.y, v1n.z + v2t.z);


			     		/*projectonvector: function (c){void 0===a&&
			     			(a=new THREE.Vector3);
			     			a.copy(c).normalize();
			     			b=this.dot(a);
			     			return this.copy(a).multiplyScalar(b)}
						*/
			     		//console.log(v2n.x + " <-2nx  1tx-> " + v1t.x + " " + v2n.y + " <-2ny  1ty-> " + v1t.y  + " " + v2n.z + " <-2nz  1tz-> "  + v1t.z + "<- hela v1a");
			     		//console.log(v1a.setLength);
			     		/*function (a){
			     			var b=this.length();
			     			0!==b&&a!==b&&this.multiplyScalar(a/b);
			     			return this} */

			     		v1a.setLength(l1);
			     		v2a.setLength(l2);
			     		//console.log(v1a.length() + "<- längd v1a efter setlength");
			     		//assign the computed velosity (times a energy loss) to the balls in the vector.
			     		balls[i].dx = v1a.x;//*secondary_energy_loss;
			     		balls[i].dy = v1a.y;//*secondary_energy_loss;
			     		balls[i].dz = v1a.z;//*secondary_energy_loss;

			     		balls[j].dx = v2a.x;//*secondary_energy_loss;
			     		balls[j].dy = v2a.y;//*secondary_energy_loss;
			     		balls[j].dz = v2a.z;//*secondary_energy_loss;

			     		if(balls[i].count >= (max_nr_of_bounces-3))
			     		balls[i].count = max_nr_of_bounces-3;
			     		if(balls[j].count >= (max_nr_of_bounces-3))
			     		balls[j].count = max_nr_of_bounces-3;

			     		//console.log(normal.length() + "<- längd normal");
			     		//var norm = new THREE.Vector3( p1.x-p2.x, p1.y-p2.y, p1.z-p2.z );
			     		//var len = norm.length();
			     		if(len>0){
			     			var coeff = (radius)/len;
			     			console.log(len + " <- len, coeff ->" + coeff);
				     		balls[i].x += coeff*normal.x;
				     		balls[i].y += coeff*normal.y;
				     		balls[i].z += coeff*normal.z;

				     		balls[j].x -= coeff*normal.x;
				     		balls[j].y -= coeff*normal.y;
				     		balls[j].z -= coeff*normal.z;
				     		console.log(normal.length());
				     	}
			     		else
			     		{
			     			console.log("wtf");
			     			console.log(normal.length() + " <- normal, len ->" + len);
				     		balls[i].x += 1;
				     		balls[i].y += 1;
				     		balls[i].z += 1;

				     		balls[j].x -= 1;
				     		balls[j].y -= 1;
				     		balls[j].z -= 1;
				     	}
			     		/*
			     		balls[i].x = balls[i].x  + 1.5*balls[i].dx;   // update position, constant velocity
						balls[i].y = balls[i].y  + 1.5*balls[i].dy;
						balls[i].z = balls[i].z  + 1.5*balls[i].dz; 

						balls[j].x = balls[j].x  + 1.5*balls[j].dx;   // update position, constant velocity
						balls[j].y = balls[j].y  + 1.5*balls[j].dy;
						balls[j].z = balls[j].z  + 1.5*balls[j].dz; 

			     		/* 
			     		
			     		temp = balls[i].dx;
			     		balls[i].dx = balls[j].dx*0.8;
			     		balls[j].dx = temp;//*0.8;

			     		temp = balls[i].dy;
			     		balls[i].dy = balls[j].dy*0.8;
			     		balls[j].dy = temp;//*0.8;

			     		temp = balls[i].dz;
			     		balls[i].dz = balls[j].dz*0.8;
			     		balls[j].dz = temp;//*0.8;
			     		balls[i].count -= 3;
			     		balls[j].count -= 3;

			     		balls[i].x = balls[i].x  + 1.5*balls[i].dx;   // update position, constant velocity
						balls[i].y = balls[i].y  + 1.5*balls[i].dy;
						balls[i].z = balls[i].z  + 1.5*balls[i].dz; 

						balls[j].x = balls[j].x  + 1.5*balls[j].dx;   // update position, constant velocity
						balls[j].y = balls[j].y  + 1.5*balls[j].dy;
						balls[j].z = balls[j].z  + 1.5*balls[j].dz; 
						*/
			     	} // end of if collision



			 	} // end of j loop

			 		if(balls[i].y > -49){
					balls[i].dy =  balls[i].dy - 9.82/1000;
					}
					balls[i].x = balls[i].x  + balls[i].dx;   // update position, constant velocity
					balls[i].y = balls[i].y  + balls[i].dy;
					balls[i].z = balls[i].z  + balls[i].dz;
					balls[i].obj.position.set( balls[i].x , balls[i].y , balls[i].z );
			     } // end of i loop


					
		    } // end of function


		    function collision(ballA, ballB)
		    {
		    	var distance = new THREE.Vector3( ballA.x-ballB.x, ballA.y-ballB.y, ballA.z-ballB.z );
		    	if(distance.length()<2){
		    		//console.log(distance.length());
		    		return true;

		    	}
		    	else
		    		return false;

		    }
		    function degInRad(deg) {
			    return deg * Math.PI / 180;
			}  

			function render() {
				renderer.render( scene, camera );
			}
		</script>
	</body>
</html>